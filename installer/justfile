# install just
# just bui

bui:
	#!/usr/bin/env bash
	set -euo pipefail
	cd bui
	./bin/cargo check
	./bin/cargo build
	$(find target -name tidb-installer)

elm-watch:
	#!/usr/bin/env bash
	set -euo pipefail
	cd bui/frontend_elm
	watch -c -n 1 make

# kube-install: kube-resources ansible-install

setup:
	#!/usr/bin/env bash
	set -euo pipefail

	minikube --help 1>/dev/null || (echo "install minikube" >&2 && exit 1)
	echo "minikube available"

	kubectl --help 1>/dev/null || (echo "download kubectl" >&2 && exit 1)
	echo "kubectl available"

	jq --help 1>/dev/null || (echo "download jq https://stedolan.github.io/jq/download/" >&2 && exit 1)
	echo "jq available"

	docker run --rm hello-world 1>/dev/null || (echo "need to setup docker" >&2 && exit 1)
	echo "docker available"

	echo "building ansible image"
	./dockerfiles/ansible/build.sh

	echo ""
	echo "   local setup is ready!"


minikube-up: setup
	#!/usr/bin/env bash
	set -euo pipefail

	echo "starting minikube"
	if [[ $(uname) == Linux ]] ; then
	  minikube start --vm-driver kvm2
	else
	  minikube start
	fi


check-tidb-user:
	#!/usr/bin/env bash
	set -euo pipefail

	cd ..
	echo "checking for tidb user"
	if ! output=$(./installer/bin/ansible ansible -i inventory.ini all -m shell -a whoami) ; then
	  if grep "UNREACHABLE" <(echo "$output") 1>/dev/null ; then
	    sleep 10
		if ! output=$(./installer/bin/ansible ansible -i inventory.ini all -m shell -a whoami) ; then
		  echo "$output" && exit 1
		fi
	  fi
	fi
	( grep tidb <(echo "$output") 1>/dev/null
	  grep -v root <(echo "$output") 1>/dev/null
	) || (echo "$output" && exit 1)
	echo "checking for root user"
	if ! output=$(./installer/bin/ansible ansible -i inventory.ini all -m shell -a whoami -b) ; then
	  echo "$output" && exit 1
	fi
	( grep root <(echo "$output") 1>/dev/null
	  grep -v tidb <(echo "$output") 1>/dev/null
	) || (echo "$output" && exit 1)


ansible-bootstrap: check-tidb-user
	cd .. && ./installer/bin/ansible ansible-playbook bootstrap.yml

ansible-deploy:
	cd .. && ./installer/bin/ansible ansible-playbook deploy.yml

ansible-start +ARGS='':
	cd .. && ./installer/bin/ansible ansible-playbook start.yml {{ARGS}}

ansible-prepare:
	cd .. && ./installer/bin/ansible ansible-playbook local_prepare.yml

# ansible-install: ansible-prepare ansible-bootstrap ansible-deploy ansible-start


kube-down: stop-services
	minikube stop


stop-services:
	#!/usr/bin/env bash
	set -euo pipefail
	# Ignore delete failures (we may have already deleted)
	for yml in kube/**/*.yml ; do
		kubectl delete -f "$yml" &
	done
	FAIL=0
	for job in `jobs -p` ; do
		wait "$job" || let "FAIL+=1"
	done



run-services:
	#!/usr/bin/env bash
	set -euo pipefail
	eval $(minikube docker-env)
	./dockerfiles/centos/build.sh

	for yml in kube/**/*.yml ; do
		kubectl create -f "$yml"
	done

	# echo "opening dashboard"
	# minikube dashboard


kube-resources: minikube-up stop-services run-services


debug:
	#!/usr/bin/env bash
	# kubectl logs -lapp=tikv -lapp=tidb -lapp=pd
	kubectl describe statefulsets
	kubectl get pods


helm-install:
	#!/usr/bin/env bash
	set -euo pipefail
	eval $(minikube docker-env)

	echo "checking for helm"
	helm --help 1>/dev/null || (echo "download helm" && exit 1)

	helm --kube-context minikube init
	helm --kube-context minikube repo add banzaicloud-incubator http://kubernetes-charts-incubator.banzaicloud.com
	if ! helm --kube-context minikube install --namespace banzai banzaicloud-incubator/tidb ; then
	  sleep 10
	  helm --kube-context minikube install --namespace banzai banzaicloud-incubator/tidb
	fi

mysql-connect:
	#!/usr/bin/env bash
	set -euo pipefail
	port="$(kubectl get svc ingress-nginx -o json | jq '.spec.ports[] | select(.name=="mysql") | .nodePort')"
	echo mysql --host "$(minikube ip)" --port "$port"


sudo=''

grafana-url:
	#!/usr/bin/env bash
	set -euo pipefail
	port="$(kubectl get svc ingress-nginx -o json | jq '.spec.ports[] | select(.name=="http") | .nodePort')"

	etc_host="$(minikube ip) monitor.local"
	if found=$(cat /etc/hosts | grep "$etc_host") ; then
	  echo "found in /etc/hosts: $found"
	#else
	  #if [[ -z "{{sudo}}" ]] ; then
	  #  echo "update /etc/hosts to: ${etc_host}"
	  #else
	  #	  if cat /etc/hosts | grep monitor.local > /dev/null ; then
	  #	    echo "update /etc/hosts to\n${etc_host}"
	  #	  else
	  #	    echo "${etc_host}" | sudo tee -a /etc/hosts > /dev/null
	  #	  fi
	  #fi
	fi

	echo "http://$(minikube ip):${port}/"

kubectl-get +ARGS='':
	#!/usr/bin/env bash
	set -euo pipefail
	kubectl get -o json {{ARGS}}

cluster-info:
	#!/usr/bin/env bash
	set -euo pipefail

	sets=$(kubectl get statefulsets -o json | jq -c '.items[] | {name: .metadata.name, status, ports: .spec.template.spec.containers[] | .ports}')
	for set in $sets ; do
	  # echo "$set"
	  name=$(echo "$set" | jq -r '.name')
	  pods=$(kubectl get pods -o json -l "app=$name" | jq -c '.items[] | {name: .metadata.name, hostname: .spec.hostname}')
	  for pod in $pods ; do
	    name=$(echo "$pod" | jq -r '.name')
	    systemctl_status=$(kubectl exec "${name}" -- systemctl status)
	    echo "${systemctl_status}"
	  done
	done

# vim: set ft=make :
