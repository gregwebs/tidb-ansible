# install just
# just bui

bui:
	#!/usr/bin/env bash
	set -euo pipefail
	cd bui
	./bin/cargo check
	./bin/cargo build
	$(find target -name tidb-installer)

elm-watch:
	#!/usr/bin/env bash
	set -euo pipefail
	cd bui/frontend_elm
	watch -c -n 1 make

bootstrap: kube-resources ansible-install

setup:
	#!/usr/bin/env bash
	set -euo pipefail

	minikube --help 1>/dev/null || (echo "install minikube" >&2 && exit 1)
	echo "minikube available"

	kubectl --help 1>/dev/null || (echo "download kubectl" >&2 && exit 1)
	echo "kubectl available"

	docker run --rm hello-world 1>/dev/null || (echo "need to setup docker" >&2 && exit 1)
	echo "docker available"

	echo "building ansible image"
	./dockerfiles/ansible/build.sh

	echo ""
	echo "   local setup is ready!"


minikube-up: setup
	#!/usr/bin/env bash
	set -euo pipefail

	echo "starting minikube"
	if [[ $(uname) == Linux ]] ; then
	  minikube start --vm-driver kvm2
	else
	  minikube start
	fi


check-tidb-user:
	#!/usr/bin/env bash
	set -euo pipefail

	cd ..
	echo "checking for tidb user"
	if ! output=$(./installer/bin/ansible ansible -i inventory.ini all -m shell -a whoami) ; then
	  if grep "UNREACHABLE" <(echo "$output") 1>/dev/null ; then
	    sleep 10
		if ! output=$(./installer/bin/ansible ansible -i inventory.ini all -m shell -a whoami) ; then
		  echo "$output" && exit 1
		fi
	  fi
	fi
	( grep tidb <(echo "$output") 1>/dev/null
	  grep -v root <(echo "$output") 1>/dev/null
	) || (echo "$output" && exit 1)
	echo "checking for root user"
	if ! output=$(./installer/bin/ansible ansible -i inventory.ini all -m shell -a whoami -b) ; then
	  echo "$output" && exit 1
	fi
	( grep root <(echo "$output") 1>/dev/null
	  grep -v tidb <(echo "$output") 1>/dev/null
	) || (echo "$output" && exit 1)


ansible-bootstrap: check-tidb-user
	cd .. && ./installer/bin/ansible ansible-playbook bootstrap.yml

ansible-deploy:
	cd .. && ./installer/bin/ansible ansible-playbook deploy.yml

ansible-start:
	cd .. && ./installer/bin/ansible ansible-playbook start.yml

ansible-prepare:
	cd .. && ./installer/bin/ansible ansible-playbook local_prepare.yml

ansible-install: ansible-prepare ansible-bootstrap ansible-deploy ansible-start


kube-down: stop-services
	minikube stop


stop-services:
	#!/usr/bin/env bash
	set -euo pipefail
	# Ignore delete failures (we may have already deleted)
	for yml in kube/**/*.yml ; do
		kubectl delete -f "$yml" &
	done
	FAIL=0
	for job in `jobs -p` ; do
		wait "$job" || let "FAIL+=1"
	done



run-services:
	#!/usr/bin/env bash
	set -euo pipefail
	eval $(minikube docker-env)
	./dockerfiles/centos/build.sh

	for yml in kube/**/*.yml ; do
		kubectl create -f "$yml"
	done

	# echo "opening dashboard"
	# minikube dashboard


kube-resources: minikube-up stop-services run-services


debug:
	#!/usr/bin/env bash
	# kubectl logs -lapp=tikv -lapp=tidb -lapp=pd
	kubectl describe statefulsets
	kubectl get pods


helm-install:
	#!/usr/bin/env bash
	set -euo pipefail
	eval $(minikube docker-env)

	echo "checking for helm"
	helm --help 1>/dev/null || (echo "download helm" && exit 1)

	helm --kube-context minikube init
	helm --kube-context minikube repo add banzaicloud-incubator http://kubernetes-charts-incubator.banzaicloud.com
	if ! helm --kube-context minikube install --namespace banzai banzaicloud-incubator/tidb ; then
	  sleep 10
	  helm --kube-context minikube install --namespace banzai banzaicloud-incubator/tidb
	fi

mysql-connect:
	#!/usr/bin/env bash
	set -euo pipefail
	port="$(kubectl get svc ingress-nginx -o json | jq '.spec.ports[] | select(.name=="mysql") | .nodePort')"
	echo mysql --host "$(minikube ip)" --port "$port"

kubectl-get ARGS='':
	#!/usr/bin/env bash
	set -euo pipefail
	kubectl get -o json {{ARGS}}

# vim: set ft=make :
